//! Generate command implementation

use anyhow::{Context, Result};
use archiver_db::ArchiverDb;
use colored::Colorize;
use std::path::PathBuf;
use crate::helpers::sort_versions_semver;

/// Generates frozen.nix file from package specification
pub fn cmd_generate(input: PathBuf, output: PathBuf, db: ArchiverDb) -> Result<()> {
    use std::fs;
    use std::io::Write;
    use regex::Regex;
    
    println!("{} Reading package specification from {}...", "üìñ".bright_cyan(), input.display());
    
    // Read input file
    let content = fs::read_to_string(&input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    // Parse Nix attribute set format: { package = "version"; }
    // Match patterns like: nodejs = "20.11.0";
    let re = Regex::new(r#"^\s*([a-zA-Z0-9_-]+)\s*=\s*"([^"]+)"\s*;?\s*$"#)
        .context("Failed to compile regex")?;
    
    let mut packages = Vec::new();
    let mut errors = Vec::new();
    
    for (line_num, line) in content.lines().enumerate() {
        let line = line.trim();
        
        // Skip empty lines, comments, and structural characters
        if line.is_empty() || line.starts_with('#') || line == "{" || line == "}" {
            continue;
        }
        
        // Try to match Nix attribute pattern
        if let Some(caps) = re.captures(line) {
            let attr_name = caps.get(1).unwrap().as_str();
            let version = caps.get(2).unwrap().as_str();
            
            // Look up in database
            match db.get(attr_name, version)? {
                Some(entry) => {
                    println!("  {} Found: {} v{} @ commit {}", 
                        "‚úì".green(), 
                        attr_name.bold(), 
                        version, 
                        &entry.commit_sha[..12].dimmed());
                    packages.push(entry);
                }
                None => {
                    errors.push(format!("Line {}: Package {}:{} not found in database", 
                        line_num + 1, attr_name, version));
                    
                    // Try to suggest available versions
                    let available = db.get_all_versions(attr_name)?;
                    if !available.is_empty() {
                        let sorted = sort_versions_semver(available);
                        let suggestions: Vec<String> = sorted.iter()
                            .take(5)
                            .map(|e| e.version.clone())
                            .collect();
                        errors.push(format!("         Available versions: {}", suggestions.join(", ")));
                    } else {
                        errors.push(format!("         No versions available for package '{}'", attr_name));
                    }
                }
            }
        } else if !line.is_empty() {
            errors.push(format!("Line {}: Invalid syntax '{}' (expected: package = \"version\";)", 
                line_num + 1, line));
        }
    }
    
    // Report errors if any
    if !errors.is_empty() {
        eprintln!("\n{} Errors found:\n", "‚ùå".red().bold());
        for error in &errors {
            eprintln!("  {}", error.red());
        }
        eprintln!("\n{} Expected input format:", "üí°".yellow());
        eprintln!("  {{\n    nodejs = \"20.11.0\";\n    python = \"3.11.7\";\n  }}");
        anyhow::bail!("Failed to resolve all packages. Fix the errors above and try again.");
    }
    
    if packages.is_empty() {
        eprintln!("{} No packages found in input file.", "‚ùå".red());
        eprintln!("\n{} Expected input format:", "üí°".yellow());
        eprintln!("  {{\n    nodejs = \"20.11.0\";\n    python = \"3.11.7\";\n  }}");
        anyhow::bail!("Input file is empty or invalid");
    }
    
    // Generate frozen.nix content
    println!("\n{} Generating frozen.nix with {} package{}...", 
        "üî®".bright_cyan(), 
        packages.len(), 
        if packages.len() == 1 { "" } else { "s" });
    
    let mut nix_content = String::from("# Generated by nix-archiver\n");
    nix_content.push_str("# This file pins packages to specific historical versions from Nixpkgs\n\n");
    nix_content.push_str("{\n");
    
    for entry in &packages {
        nix_content.push_str(&format!("  # {} v{} (commit: {})\n", 
            entry.attr_name, entry.version, &entry.commit_sha));
        nix_content.push_str(&format!("  {} = import ({}) {{}};\n\n", 
            entry.attr_name, 
            entry.to_nix_fetchtarball()));
    }
    
    nix_content.push_str("}\n");
    
    // Write to output file
    let mut file = fs::File::create(&output)
        .with_context(|| format!("Failed to create output file: {}", output.display()))?;
    
    file.write_all(nix_content.as_bytes())
        .with_context(|| format!("Failed to write to output file: {}", output.display()))?;
    
    println!("{} Successfully generated: {}", "‚úì".green().bold(), output.display().to_string().bold());
    println!("\n{} Usage:\n  nix-shell {}", "üí°".yellow(), output.display());
    
    Ok(())
}
