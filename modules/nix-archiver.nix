{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.nix-archiver;

  # Generate packages.nix from pinnedPackages
  packagesFile = pkgs.writeText "packages.nix" ''
    # Auto-generated by nix-archiver NixOS module
    {
      ${concatStringsSep "\n  " (mapAttrsToList (name: version: ''${name} = "${version}";'') cfg.pinnedPackages)}
    }
  '';

  # Generate overlay if enabled
  nixArchiverOverlay = self: super:
    let
      pinnedPkgs = import (pkgs.runCommand "nix-archiver-pinned-packages" {
        buildInputs = [ cfg.package ];
      } ''
        mkdir -p $out
        ${cfg.package}/bin/nix-archiver generate \
          --input ${packagesFile} \
          --output $out/frozen.nix \
          --database ${cfg.indexer.database}
      '');
    in
    if cfg.generateOverlay && cfg.pinnedPackages != {}
    then pinnedPkgs
    else {};

in {
  imports = [
    ./options.nix
  ];

  config = mkIf cfg.enable {
    # Ensure the package is available
    environment.systemPackages = [ cfg.package ];

    # Create state directory
    systemd.tmpfiles.rules = [
      "d ${cfg.stateDirectory} 0755 nix-archiver nix-archiver -"
      "d ${cfg.indexer.database} 0755 nix-archiver nix-archiver -"
      "d ${dirOf cfg.indexer.repository} 0755 nix-archiver nix-archiver -"
    ];

    # Create nix-archiver user
    users.users.nix-archiver = {
      isSystemUser = true;
      group = "nix-archiver";
      home = cfg.stateDirectory;
      description = "Nix-Archiver service user";
    };

    users.groups.nix-archiver = {};

    # Systemd service for indexer
    systemd.services.nix-archiver-indexer = mkIf cfg.indexer.enable {
      description = "Nix-Archiver Repository Indexer";
      after = [ "network.target" ];
      wants = [ "network.target" ];

      serviceConfig = {
        Type = "oneshot";
        User = "nix-archiver";
        Group = "nix-archiver";
        ExecStartPre = mkIf (!pathExists cfg.indexer.repository) (
          pkgs.writeScript "clone-nixpkgs" ''
            #!${pkgs.bash}/bin/bash
            if [ ! -d "${cfg.indexer.repository}" ]; then
              ${pkgs.git}/bin/git clone https://github.com/NixOS/nixpkgs.git "${cfg.indexer.repository}"
            fi
          ''
        );
        ExecStart = pkgs.writeScript "nix-archiver-index" ''
          #!${pkgs.bash}/bin/bash
          set -e
          
          # Update repository if it exists
          if [ -d "${cfg.indexer.repository}" ]; then
            cd "${cfg.indexer.repository}"
            ${pkgs.git}/bin/git fetch origin
            ${pkgs.git}/bin/git reset --hard origin/master
          fi
          
          # Run indexer
          ${cfg.package}/bin/nix-archiver \
            --database ${cfg.indexer.database} \
            --log-level ${cfg.logLevel} \
            index \
            --repo ${cfg.indexer.repository} \
            --from HEAD \
            ${optionalString (cfg.indexer.maxCommits != null) "--max-commits ${toString cfg.indexer.maxCommits}"} \
            --batch-size ${toString cfg.indexer.batchSize} \
            ${optionalString (cfg.indexer.threads != null) "--threads ${toString cfg.indexer.threads}"}
        '';
        StateDirectory = "nix-archiver";
        WorkingDirectory = cfg.stateDirectory;
      };
    };

    # Systemd timer for periodic updates
    systemd.timers.nix-archiver-indexer = mkIf cfg.indexer.enable {
      description = "Nix-Archiver Indexer Timer";
      wantedBy = [ "timers.target" ];
      
      timerConfig = {
        OnCalendar = cfg.indexer.updateInterval;
        Persistent = true;
        RandomizedDelaySec = "1h";
      };
    };

    # Apply overlay if enabled
    nixpkgs.overlays = mkIf (cfg.generateOverlay && cfg.pinnedPackages != {}) [
      nixArchiverOverlay
    ];

    # Add CLI wrapper with database path
    environment.shellAliases = {
      nix-archiver = "${cfg.package}/bin/nix-archiver --database ${cfg.indexer.database}";
    };
  };
}
